rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ======================================================
    // SECURITY HELPERS
    // ======================================================
    
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is an active admin in the new system
    function isAdmin() {
      return isSuperAdmin() || (
        isAuthenticated() && 
        exists(/databases/$(database)/documents/admins/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.isActive == true
      );
    }

    // Check if user is a super admin
    function isSuperAdmin() {
      return isAuthenticated() && (
        request.auth.token.email in ['batchcrick@gmail.com', 'mehedihasan110571@gmail.com', 'faysalmia4125@gmail.com'] || (
          exists(/databases/$(database)/documents/admins/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.role == 'super_admin'
        )
      );
    }

    // Check if the current user owns the document via adminId
    function isOwner(data) {
      return isAuthenticated() && (data.adminId == request.auth.uid || isSuperAdmin());
    }

    // Legacy admin check
    function isLegacyAdmin() {
      return isAuthenticated() && (
        exists(/databases/$(database)/documents/admin/$(request.auth.uid)) ||
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'super_admin']) ||
        request.auth.token.email == 'batchcrick@gmail.com'
      );
    }

    // Combined admin check (prefers new system)
    function isAnyAdmin() {
      return isAdmin() || isLegacyAdmin();
    }

    // ======================================================
    // ADMIN IDENTITY & OWNERSHIP
    // ======================================================

    match /admins/{adminId} {
      // Admins can read their own profile, Super Admins can read all, 
      // or if searching specifically for their own email (for promotion)
      allow read: if isAuthenticated() && (
        request.auth.uid == adminId || 
        isSuperAdmin() || 
        (resource != null && request.auth.token.email != null && 
         resource.data.email.lower() == request.auth.token.email.lower())
      );
      
      // Allow Super Admin to create any admin (including themselves)
      allow create: if isSuperAdmin();
                    
      // Only super admin can activate or change roles
      allow update: if isSuperAdmin() || (isAdmin() && request.auth.uid == adminId && 
                    !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'isActive']));
                    
      allow delete: if isSuperAdmin();
    }

    match /invited_admins/{email} {
      // Allow read for the person being invited (to check during login) or any Super Admin
      allow read: if isAuthenticated() && (request.auth.token.email.lower() == email.lower() || isSuperAdmin());
      // Only Super Admin can invite/delete invites
      allow write: if isSuperAdmin();
    }

    // ======================================================
    // CORE DATA COLLECTIONS (Public Read, Admin Write)
    // ======================================================

    match /tournaments/{id} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update, delete: if isAdmin() && isOwner(resource.data);
    }

    match /matches/{matchId} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update, delete: if isAdmin() && isOwner(resource.data);
      
      match /commentary/{id} {
        allow read: if true;
        allow write: if isAdmin() && isOwner(get(/databases/$(database)/documents/matches/$(matchId)).data);
      }
      
      match /innings/{inningId} {
        allow read: if true;
        allow write: if isAdmin() && isOwner(get(/databases/$(database)/documents/matches/$(matchId)).data);

        match /balls/{ballId} {
          allow read: if true;
          allow write: if isAdmin() && isOwner(get(/databases/$(database)/documents/matches/$(matchId)).data);
        }
      }
    }

    match /squads/{id} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update, delete: if isAdmin() && isOwner(resource.data);
    }

    // ======================================================
    // PLAYER DOCUMENTS (HARDENED)
    // ======================================================
    // SECURITY: ownerUid, claimed, email, maskedEmail fields are
    // ONLY modifiable by admin or Cloud Functions.
    // Players (owners) can update personal info BUT NOT ownership fields.
    // ======================================================

    match /players/{playerId} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow delete: if isAdmin() && isOwner(resource.data);
      
      allow update: if (isAdmin() && isOwner(resource.data)) || (
        isAuthenticated() && (
          // CASE 1: Updating an already owned profile (limited fields)
          (resource.data.ownerUid == request.auth.uid && 
           !request.resource.data.diff(resource.data).affectedKeys().hasAny([
             'id', 'squadId', 'claimed', 'ownerUid', 'email', 'maskedEmail',
             'createdAt', 'createdBy', 'adminId', 'adminEmail'
           ])) ||
          // CASE 2: Securely claiming an unclaimed profile
          (resource.data.ownerUid == null && 
           request.resource.data.ownerUid == request.auth.uid &&
           request.resource.data.claimed == true)
        )
      );
    }

    // ======================================================
    // PLAYER SECRETS (STRICT)
    // ======================================================
    // Contains raw email. Only admin (of the player) or the
    // player's email holder can read. Only admin can write.
    // Cloud Functions bypass these rules (Admin SDK).
    // ======================================================

    match /player_secrets/{playerId} {
      // Allow read if user is authenticated and is either admin OR the email matches
      allow read: if isAuthenticated() && (
        isAdmin() || 
        (resource == null) ||
        (request.auth.token.email != null && resource.data.email != null && 
         request.auth.token.email.lower() == resource.data.email.lower())
      );
      
      allow write: if isAdmin();
    }

    // ======================================================
    // PRIVATE DATA & SETTINGS
    // ======================================================

    match /notifications/{id} {
      allow read, write: if isAdmin() && (isOwner(resource.data) || request.resource.data.adminId == request.auth.uid);
    }

    match /settings/{id} {
      allow read: if true;
      allow write: if isAdmin() && (isOwner(resource.data) || request.resource.data.adminId == request.auth.uid);
    }

    match /playerMatchStats/{statId} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update, delete: if isAdmin() && isOwner(resource.data);
    }

    // ======================================================
    // SYSTEM & LOGS
    // ======================================================

    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && (request.auth.uid == userId || isSuperAdmin());
    }

    // ======================================================
    // AUDIT LOGS (SECURITY CRITICAL)
    // ======================================================
    // Admins can create audit logs. No one can update or delete.
    // Super admins can read for oversight.
    // ======================================================

    match /audit_logs/{logId} {
      allow read: if isSuperAdmin();
      allow create: if isAdmin();   // Admin can write from client
      allow update: if false;       // Immutable - no edits allowed
      allow delete: if false;       // Never delete audit trails
    }

    // ======================================================
    // PLAYER REGISTRATION SYSTEM
    // ======================================================

    match /player_requests/{requestId} {
      // Allow user to create their own request
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid;
      
      // Single doc read: user owns it, or is admin
      allow get: if isAuthenticated() && (request.auth.uid == resource.data.uid || isAdmin());
      
      // List/query: user must filter by their own uid, or be admin
      allow list: if isAuthenticated() && (
        resource.data.uid == request.auth.uid || isAdmin()
      );
      
      // Allow admins OR the owner (if pending) to update
      allow update: if isAdmin() || (
        isAuthenticated() && 
        resource.data.uid == request.auth.uid && 
        resource.data.status == 'pending'
      );
      
      allow delete: if isAdmin();
    }

    match /permitted_admins/{email} {
      allow read: if isAuthenticated() && (isAnyAdmin() || request.auth.token.email.lower() == email.lower());
      allow write: if isSuperAdmin();
    }

    match /champions/{id} {
      allow read: if true;
      allow create: if isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update, delete: if isAdmin() && isOwner(resource.data);
    }

    // LEGACY: Old admin collection (should be migrated)
    match /admin/{adminId} {
      allow read: if isAuthenticated() && request.auth.uid == adminId;
      allow write: if false; // Block new writes to legacy collection
    }

    match /email_logs/{logId} {
      allow read: if isSuperAdmin();
      allow create: if isAdmin() || isSuperAdmin();
    }

    match /matchVotes/{matchId} {
      allow read: if true;
      allow create, update: if true;
    }
  }
}
